"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformSwaggerV3 = void 0;
const types_1 = require("../types");
const info_1 = require("./common/v2-3/info");
const path_1 = require("./v3/path");
const markdown_1 = require("../lib/markdown");
const Tags_1 = require("./common/Tags");
const externalDocs_1 = require("./common/v2-3/externalDocs");
const tag_1 = require("./common/v2-3/tag");
const groupPathsByTags_1 = require("./common/v2-3/groupPathsByTags");
const components_1 = require("./v3/components/components");
const securitySchemes_1 = require("./v3/securitySchemes/securitySchemes");
function transformSwaggerV3(inputDoc, options) {
    const md = markdown_1.Markdown.md();
    // Skip servers
    // those are used for the mock server and won't be rendered
    // Security and Responses are supposed to be dereferenced
    // and shall not be present in the root namespace
    // Process info
    if (!options.skipInfo && 'info' in inputDoc) {
        md.line((0, info_1.transformInfo)(inputDoc.info));
    }
    // Collect tags
    const tagsCollection = new Tags_1.TagsCollection();
    if ('tags' in inputDoc) {
        inputDoc.tags.forEach((tag) => {
            tagsCollection.tag(tag);
        });
    }
    if ('externalDocs' in inputDoc) {
        md.line((0, externalDocs_1.transformExternalDocs)(inputDoc.externalDocs));
    }
    if ('securitySchemes' in inputDoc.components) {
        md.line((0, securitySchemes_1.transformSecuritySchemes)(inputDoc.components.securitySchemes));
    }
    // All components must be dereferenced
    // Process Paths
    if ('paths' in inputDoc) {
        // Group paths by tag name
        const tagged = (0, groupPathsByTags_1.groupPathsByTags)(inputDoc.paths, types_1.ALLOWED_METHODS_V3);
        Object.keys(tagged).forEach((tagName) => {
            md.line(md.string().horizontalRule());
            if (tagsCollection.length) {
                // Display Tag
                const tagObject = tagsCollection.getTag(tagName) || '';
                md.line((0, tag_1.transformTag)(tagObject));
            }
            const pathsUnderTag = tagged[tagName];
            Object.keys(pathsUnderTag).forEach((path) => md.line((0, path_1.transformPath)(path, inputDoc.paths[path])));
        });
    }
    // Models (components)
    if ('components' in inputDoc) {
        md.line(md.string().horizontalRule());
        md.line((0, components_1.transformComponents)(inputDoc.components));
    }
    // Glue all pieces down
    return md.export();
}
exports.transformSwaggerV3 = transformSwaggerV3;
