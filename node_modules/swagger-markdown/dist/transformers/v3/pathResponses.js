"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformResponses = exports.hasLinksInResponses = exports.hasSchemasInResponses = void 0;
const markdown_1 = require("../../lib/markdown");
const headers_1 = require("../common/v2-3/headers");
const link_1 = require("./link");
const dataTypes_1 = require("./dataTypes");
const Schema_1 = require("./models/Schema");
/**
 * Checks if the given response object contains a schema.
 *
 * @param response - An OpenAPI V3 response object.
 * @returns A boolean indicating whether the response contains a schema.
 */
function hasSchemaInResponse(response) {
    if ('content' in response) {
        return Object.values(response.content).some((data) => 'schema' in data);
    }
    return false;
}
/**
 * Checks if any response in the given responses object contains schemas.
 *
 * @param responses - An object containing OpenAPI V3 response objects.
 * @returns A boolean indicating whether any res
 * ponse contains schemas.
 */
function hasSchemasInResponses(responses) {
    return Object.values(responses).some(hasSchemaInResponse);
}
exports.hasSchemasInResponses = hasSchemasInResponses;
/**
 * Checks if any response in the given responses object contains links.
 *
 * @param responses - An object containing OpenAPI V3 response objects.
 * @returns A boolean indicating whether any response contains links.
 */
function hasLinksInResponses(responses) {
    return Object.values(responses).some((response) => 'links' in response);
}
exports.hasLinksInResponses = hasLinksInResponses;
/**
 * Build responses table
 */
function transformResponses(responses) {
    const md = markdown_1.Markdown.md();
    md.line(md.string('Responses').h4()).line();
    const hasSchemas = hasSchemasInResponses(responses);
    const hasLinks = hasLinksInResponses(responses);
    const table = md.table();
    table.th('Code').th('Description');
    if (hasSchemas) {
        table.th('Schema');
    }
    if (hasLinks) {
        table.th('Links');
    }
    Object.keys(responses).forEach((responseCode) => {
        const tr = table.tr();
        const response = responses[responseCode];
        // Response
        tr.td(responseCode);
        // Description
        const description = md.string();
        if ('description' in response) {
            description.concat(md.string(response.description.replace(/[\r\n]/g, ' ')).escape());
        }
        if ('headers' in response) {
            description.concat(md.string('').br(true));
            description.concat((0, headers_1.transformHeaders)(response.headers));
        }
        tr.td(description);
        // Schema
        if (hasSchemaInResponse(response)) {
            const { content } = response;
            if (content) {
                const td = md.string();
                Object.keys(content).forEach((contentType) => {
                    const { schema } = content[contentType];
                    if (schema) {
                        const schemaObject = new Schema_1.Schema(schema);
                        // tr.td(dataTypeResolver(schemaObject));
                        td.concat(`${md.string(contentType).bold()}: `);
                        td.concat((0, dataTypes_1.dataTypeResolver)(schemaObject)).br(true);
                    }
                });
                tr.td(td);
            }
            else {
                tr.td('');
            }
        }
        else if (hasSchemas) {
            tr.td('');
        }
        if ('links' in response) {
            const linksMd = md.string();
            Object.keys(response.links).forEach((linkName) => {
                const link = response.links[linkName];
                linksMd.concat((0, link_1.processLink)(linkName, link));
            });
            tr.td(linksMd);
        }
        else if (hasLinks) {
            tr.td('');
        }
    });
    md.line(table);
    return md.export();
}
exports.transformResponses = transformResponses;
