"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processSchemas = void 0;
const markdown_1 = require("../../../lib/markdown");
const mdtable_1 = require("../../../lib/markdown/mdtable");
const Schema_1 = require("../models/Schema");
const dataTypes_1 = require("../dataTypes");
/**
 * Parse allOf definition
 * @param name of the definition
 * @param definition definition object
 */
function parsePrimitive(name, definition) {
    const tr = mdtable_1.MDtableRow.tr();
    const typeCell = 'type' in definition ? definition.type : '';
    const descriptionCell = ('description' in definition ? definition.description : '').replace(/[\r\n]/g, ' ');
    const requiredCell = '';
    tr.td(name)
        .td(Array.isArray(typeCell) ? typeCell.join(', ') : typeCell)
        .td(descriptionCell)
        .td(requiredCell);
    return tr;
}
/**
 * Parse the Property field if present.
 * @param name of the definition
 * @param definition definition object
 */
function parseProperties(definition) {
    const rows = [];
    const md = markdown_1.Markdown.md();
    const required = 'required' in definition ? definition.required : [];
    Object.keys(definition.properties).forEach((propName) => {
        const tr = mdtable_1.MDtableRow.tr();
        const prop = definition.properties[propName];
        const typeCell = (0, dataTypes_1.dataTypeResolver)(new Schema_1.Schema(prop));
        const descriptionParts = [];
        if ('description' in prop) {
            descriptionParts.push(md.string(prop.description.replace(/[\r\n]/g, ' ')).escape().get());
        }
        if ('enum' in prop) {
            const enumValues = prop.enum.map((val) => `\`${JSON.stringify(val)}\``).join(', ');
            descriptionParts.push(md.string('Enum:').italic().concat(` ${enumValues}`).get());
        }
        if ('example' in prop) {
            descriptionParts.push(md.string('Example:').italic().concat(` \`${JSON.stringify(prop.example)}\``).get());
        }
        const descriptionCell = descriptionParts.join('<br>');
        const requiredCell = required.includes(propName) ? 'Yes' : 'No';
        tr.td(propName).td(typeCell).td(descriptionCell).td(requiredCell);
        rows.push(tr);
    });
    return rows;
}
function processSchemas(schemas) {
    const md = markdown_1.Markdown.md();
    Object.keys(schemas).forEach((schemaName) => {
        const schema = schemas[schemaName];
        md.line()
            .line(md.string(schemaName).h4())
            .line();
        if (schema.description) {
            md.line(schema.description)
                .line();
        }
        const table = md.table();
        table.th('Name').th('Type').th('Description').th('Required');
        if ('properties' in schema) {
            const parsedProperties = (parseProperties(schema));
            parsedProperties.forEach((row) => table.insertRow(row));
        }
        else {
            table.insertRow(parsePrimitive(schemaName, schema));
        }
        md.line(table);
        if (schema.example) {
            const formattedExample = typeof schema.example === 'string'
                ? schema.example
                : JSON.stringify(schema.example, null, '  ');
            md.line()
                .line(md.string('Example').bold())
                .line(`<pre>${formattedExample}</pre>`);
        }
    });
    return md.export();
}
exports.processSchemas = processSchemas;
