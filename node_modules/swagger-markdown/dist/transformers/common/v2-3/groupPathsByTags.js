"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.groupPathsByTags = void 0;
/**
 * Group path and methods by tags they have
 */
function groupPathsByTags(inputDoc, allowedMethods) {
    const tagged = {};
    Object.keys(inputDoc).forEach((path) => {
        const data = inputDoc[path];
        Object.keys(data).forEach((method) => {
            if (allowedMethods.includes(method)) {
                const pathMethod = data[method];
                const tags = pathMethod.tags || [''];
                tags.forEach((tagName) => {
                    if (tagName === '__proto__' || tagName === 'constructor' || tagName === 'prototype') {
                        return; // Skip special properties to prevent prototype pollution
                    }
                    if (!tagged[tagName]) {
                        // Initialize as an empty PathsObject of the correct type T
                        tagged[tagName] = {};
                    }
                    // Ensure the path exists within the tag's PathsObject
                    if (!tagged[tagName][path]) {
                        // Initialize the PathItemObject for this path, copying common elements
                        tagged[tagName][path] = Object.assign(Object.assign({}, (data.parameters && { parameters: data.parameters })), (data.$ref && { $ref: data.$ref })); // Cast to the expected PathItemObject type
                    }
                    // Add the specific method to the PathItemObject
                    // Assert type to allow dynamic method assignment
                    const pathItem = tagged[tagName][path];
                    pathItem[method] = pathMethod;
                });
            }
        });
    });
    return tagged;
}
exports.groupPathsByTags = groupPathsByTags;
